/*
 * cli.c
 *
 *  Created on: Aug 18, 2024
 *      Author: Sicris Rey Embay
 */

#include "stdbool.h"
#include "string.h"
#include "FreeRTOS.h"
#include "task.h"
#include "FreeRTOS-Plus-CLI/FreeRTOS_CLI.h"
#include "lpuart.h"
#include "cli.h"

#define CLI_TASK_PRIORITY               (1)
#define CLI_TASK_STACK_SIZE             (512)
#define CLI_COMMAND_MAX_INPUT_SIZE      (256)
#define CLI_COMMAND_MAX_OUTPUT_SIZE     (256)

static bool bInit = false;
static TaskHandle_t taskHandle = NULL;
static StaticTask_t taskStruct = {0};
static StackType_t taskStackStorage[CLI_TASK_STACK_SIZE] = {0};
static char input_strBuf[CLI_COMMAND_MAX_INPUT_SIZE];

static const char * const welcomeString = "\r\n\n"
        "******************************************************\r\n"
        "* Type 'help' to view a list of registered commands.\r\n"
        "******************************************************\r\n";
static const char * const strLineSep = "\r\n";
static const char * const strPrompt = "$ ";


static void helper_send_blocking(char * pBuf, size_t count)
{
    LPUART_Send((uint8_t *)pBuf, count);
    while(!LPUART_TxDone()) {
        vTaskDelay(10);
    }
}


static void task_cli(void * pvParam)
{
    int16_t inputIndex = 0;
    int16_t moreDataToFollow = 0;
    char * output_str_buf = NULL;
    char rxChar = 0;

    output_str_buf = FreeRTOS_CLIGetOutputBuffer();

    /* print welcome string */
    helper_send_blocking((char *)welcomeString, strlen(welcomeString));
    /* print prompt symbol */
    helper_send_blocking((char *)strPrompt, 2);

    TickType_t xLastWakeTime = xTaskGetTickCount();

    while(1) {
        if(LPUART_Receive((uint8_t *)&rxChar, 1) > 0) {
            if((rxChar < 0x00) || (rxChar > 0x7F)) {
                continue;
            }
            if(rxChar == '\n') {
                /*
                 * A newline character was received, so the input command string is
                 * complete and can be processed.  Transmit a line separator, just to
                 * make the output easier to read.
                 */
                helper_send_blocking((char *)strLineSep, strlen(strLineSep));
                helper_send_blocking((char *)strLineSep, strlen(strLineSep));

                if(strlen(input_strBuf) == 0) {
                    /* No command to process */
                    /* Just print prompt */
                    helper_send_blocking((char *)strPrompt, 2);
                    inputIndex = 0;
                    continue;
                }

                /*
                 * The command interpreter is called repeatedly until it returns
                 * pdFALSE (0).
                 */
                do {
                    /*
                     * Send the command string to the command interpreter.  Any
                     * output generated by the command interpreter will be placed in the
                     * output_str_buf buffer.
                     */
                    moreDataToFollow = FreeRTOS_CLIProcessCommand
                                  (
                                      input_strBuf,                         /* The command string.*/
                                      output_str_buf,                       /* The output buffer. */
                                      CLI_COMMAND_MAX_OUTPUT_SIZE    /* The size of the output buffer. */
                                  );

                    /*
                     * Write the output generated by the command interpreter to the
                     * console.
                     */
                    helper_send_blocking(output_str_buf, strlen(output_str_buf));

                } while( moreDataToFollow != 0 );

                /*
                 * All the strings generated by the input command have been sent.
                 * Processing of the command is complete.  Clear the input string ready
                 * to receive the next command.
                 */
                inputIndex = 0;
                memset( input_strBuf, 0x00, sizeof(input_strBuf) );

                /* print prompt symbol */
                helper_send_blocking((char *)strPrompt, 2);
            } else {
                /*
                 * The if() clause performs the processing after a newline character
                 * is received.  This else clause performs the processing if any other
                 * character is received. */
                if( rxChar == '\r' ) {
                    /* Ignore carriage returns. */
                } else if( rxChar == '\b' ) {
                    /*
                     * Backspace was pressed.  Erase the last character in the input
                     * buffer - if there are any
                     */
                    if( inputIndex > 0 ) {
                        inputIndex--;
                        input_strBuf[ inputIndex ] = '\0';
                    }
                } else {
                    /*
                     * A character was entered.  It was not a new line, backspace
                     * or carriage return, so it is accepted as part of the input and
                     * placed into the input buffer.  When a n is entered the complete
                     * string will be passed to the command interpreter.
                     */
                    if( inputIndex < CLI_COMMAND_MAX_INPUT_SIZE ) {
                        input_strBuf[ inputIndex ] = rxChar;
                        inputIndex++;
                    }
                }
            }
        } else {
            vTaskDelayUntil(&xLastWakeTime, 10);
        }
    }
}


void CLI_init(void)
{
    if(bInit != true) {
        LPUART_Init();
        taskHandle = xTaskCreateStatic(task_cli,
                              "cli",
                              CLI_TASK_STACK_SIZE,
                              (void *)0,
                              CLI_TASK_PRIORITY,
                              taskStackStorage,
                              &taskStruct);
        configASSERT(taskHandle != NULL);

        bInit = true;
    }
}

